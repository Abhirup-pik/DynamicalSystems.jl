{
    "docs": [
        {
            "location": "/", 
            "text": "DynamicalSystems.jl\n is a Julia package for the exploration of continuous and discrete dynamical systems. it aims to be a useful and powerful companion for students and scientists treading on the field of Chaos, nonlinear dynamics and dynamical systems in general. The package treats discrete and continuous systems of the forms:\n\n\n\n\n\n\\frac{d\\vec{u}}{dt} = \\vec{f}(\\vec{u}) \\quad \\text{or}\\quad \\vec{x}_{n+1} = \\vec{f}(\\vec{x}_n)\n\n\n\n\n\nas well as numerical data. More information is contained in the \nSystems Definition\n page.\n\n\nThis is the (non-final) list of what this package aims to offer:\n\n\n\n\nIntuitive, consistent APIs for the definition of dynamical systems.\n\n\nAutomatic \"completion\" of the dynamics of the system with numerically computed\n\n\n\n\nJacobians, in case they are not provided by the user.\n\n\n\n\nLyapunov exponent estimation.\n\n\nEntropy estimation.\n\n\nAttractor dimension estimation.\n\n\nEntropy/Attractor dimension/Lyapunov exponents for \nnumerical data\n.\n\n\nChaos control.\n\n\nOther stuff I have not yet decided upon, since this is like a pre-alpha version.\n\n\nSuggest or Contribute more stuff! (see contributors guide).", 
            "title": "Introduction"
        }, 
        {
            "location": "/system_definition/", 
            "text": "System Definition\n\n\nFor \nDynamicalSystems.jl\n a system is simple a structure that contains the system's state, the equations of motion and the Jacobian. The last two are \nfunctions\n that take as an input a state. This page treats systems where one already \nknows the equations of motion\n.\n\n\nBy taking advantage of the package \nForwardDiff.jl\n an automated Jacobian function can always be supplemented by the package. More details are enclosed in the indivivdual sections, however the documentation strings of all the constructors are also self-contained.\n\n\n\n\nNon-autonomous systems\n\n\nThis package does \nnot\n accept non-autonomous systems. To use such systems with this package increase the dimensionality of your system by 1, by introducing an additional variable $\\tau$ such that $d\\tau/dt = 1$ (or $\\tau_{n+1} = \\tau_n + 1$). This additional variable will serve as the \"time\" in your equations of motion.\n\n\n\n\n\n\nDiscrete Systems\n\n\nDiscrete systems are of the form:\n\n\n\n\n\n\\vec{x}_{n+1} = \\vec{f}(\\vec{x}_n).\n\n\n\n\n\nThe Type representing such systems for dimensionality \nD \u2264 10\n is called \nDiscreteDS\n.\n\n\nThe constructor is:\n\n\nDiscreteDS\n(\nstate\n,\n \neom\n \n[,\n \njacob\n])\n\n\n\n\n\n\nHere \nstate\n is simply the state the system starts (a.k.a. initial conditions) and \neom\n is a \nfunction\n that takes a \nstate\n as an input and returns the next state as an output.\n\n\nThe \njacob\n is also a \nfunction\n that takes a \nstate\n as an input and returns the Jacobian matrix of the system (at this state). This however is optional and if not provided by the user, will be calculated automatically using the package \nForwardDiff.jl\n.\n\n\n\n\nReturn form of the \neom\n function for small \nD\n\n\nIt is \nheavily\n advised that the equations of motion \neom\n function returns an \nSVector\n from the julia package \nStaticArrays.jl\n and similarly the \njacob\n function returns an \nSMatrix\n. \nNumerous benchmarks\n have been made in order to deduce the most efficient possible way to define a system, and this way was proved to be the best.\n\n\n\n\nFor example, let's create one of the \nPredefined Systems\n offered by this package, the H\u00e9non map:\n\n\nusing\n \nDynamicalSystems\n\n\nusing\n \nStaticArrays\n \n#only necessary when defining a system\n\n\n\neom_henon\n(\nx\n)\n \n=\n \nSVector\n{\n2\n}(\n1.0\n \n-\n \na\n*\nx\n[\n1\n]\n^\n2\n \n+\n \nx\n[\n2\n],\n \nb\n*\nx\n[\n1\n])\n\n\njacob_henon\n(\nx\n)\n \n=\n \n@SMatrix\n \n[\n-\n2\n*\na\n*\nx\n[\n1\n]\n \n1.0\n;\n \nb\n \n0.0\n]\n\n\n\nds\n \n=\n \nDiscreteDS\n(\nrand\n(\n2\n),\n \neom_henon\n,\n \njacob_henon\n)\n\n\n\n\n\n\nIf we did not want to write a Jacobian (due to e.g. unending laziness), we could\n\n\nds_nojac\n \n=\n \nDiscreteDS\n(\nrand\n(\n2\n),\n \neom_henon\n)\n\n\n\n\n\n\nand the Jacobian function would be created automatically.\n\n\n\n\nLarge Discrete Systems\n\n\nTBA\n\n\n\n\n1-dimensional Discrete Systems\n\n\nIn the case of maps, there a special structure for one-dimensional systems, since they are commonly used in scientific research. The syntax is \nDiscreteDS1D(state, eom [, deriv])\n. In this one-dimensional case, you don't need to worry about \nStaticArrays.jl\n because everything is in plain numbers. For example:\n\n\nusing\n \nDynamicalSystems\n\n\n\n@inline\n \neom_logistic\n(\nr\n)\n \n=\n \n(\nx\n)\n \n-\n \nr\n*\nx\n*\n(\n1\n-\nx\n)\n  \n# this is a closure\n\n\n@inline\n \nderiv_logistic\n(\nr\n)\n \n=\n \n(\nx\n)\n \n-\n \nr\n*\n(\n1\n-\n2\nx\n)\n \n# this is a closure\n\n\nr\n \n=\n \n3.7\n\n\nlogistic\n \n=\n \nDiscreteDS1D\n(\nrand\n(),\n \neom_logistic\n(\nr\n),\n \nderiv_logistic\n(\nr\n))\n\n\n\n\n\n\nOnce again, if you skip the derivative functions it will be calculated automatically using \nForwardDiff.jl\n.\n\n\n\n\nContinuous Systems\n\n\nTBA\n\n\n\n\nPredefined Systems\n\n\nTBA\n\n\n\n\nNumerical Data\n\n\nTBA\n\n\n\n\nConvenience Functions\n\n\nTBA", 
            "title": "System Definition"
        }, 
        {
            "location": "/system_definition/#system-definition", 
            "text": "For  DynamicalSystems.jl  a system is simple a structure that contains the system's state, the equations of motion and the Jacobian. The last two are  functions  that take as an input a state. This page treats systems where one already  knows the equations of motion .  By taking advantage of the package  ForwardDiff.jl  an automated Jacobian function can always be supplemented by the package. More details are enclosed in the indivivdual sections, however the documentation strings of all the constructors are also self-contained.   Non-autonomous systems  This package does  not  accept non-autonomous systems. To use such systems with this package increase the dimensionality of your system by 1, by introducing an additional variable $\\tau$ such that $d\\tau/dt = 1$ (or $\\tau_{n+1} = \\tau_n + 1$). This additional variable will serve as the \"time\" in your equations of motion.", 
            "title": "System Definition"
        }, 
        {
            "location": "/system_definition/#discrete-systems", 
            "text": "Discrete systems are of the form:   \n\\vec{x}_{n+1} = \\vec{f}(\\vec{x}_n).   The Type representing such systems for dimensionality  D \u2264 10  is called  DiscreteDS .  The constructor is:  DiscreteDS ( state ,   eom   [,   jacob ])   Here  state  is simply the state the system starts (a.k.a. initial conditions) and  eom  is a  function  that takes a  state  as an input and returns the next state as an output.  The  jacob  is also a  function  that takes a  state  as an input and returns the Jacobian matrix of the system (at this state). This however is optional and if not provided by the user, will be calculated automatically using the package  ForwardDiff.jl .   Return form of the  eom  function for small  D  It is  heavily  advised that the equations of motion  eom  function returns an  SVector  from the julia package  StaticArrays.jl  and similarly the  jacob  function returns an  SMatrix .  Numerous benchmarks  have been made in order to deduce the most efficient possible way to define a system, and this way was proved to be the best.   For example, let's create one of the  Predefined Systems  offered by this package, the H\u00e9non map:  using   DynamicalSystems  using   StaticArrays   #only necessary when defining a system  eom_henon ( x )   =   SVector { 2 }( 1.0   -   a * x [ 1 ] ^ 2   +   x [ 2 ],   b * x [ 1 ])  jacob_henon ( x )   =   @SMatrix   [ - 2 * a * x [ 1 ]   1.0 ;   b   0.0 ]  ds   =   DiscreteDS ( rand ( 2 ),   eom_henon ,   jacob_henon )   If we did not want to write a Jacobian (due to e.g. unending laziness), we could  ds_nojac   =   DiscreteDS ( rand ( 2 ),   eom_henon )   and the Jacobian function would be created automatically.", 
            "title": "Discrete Systems"
        }, 
        {
            "location": "/system_definition/#large-discrete-systems", 
            "text": "TBA", 
            "title": "Large Discrete Systems"
        }, 
        {
            "location": "/system_definition/#1-dimensional-discrete-systems", 
            "text": "In the case of maps, there a special structure for one-dimensional systems, since they are commonly used in scientific research. The syntax is  DiscreteDS1D(state, eom [, deriv]) . In this one-dimensional case, you don't need to worry about  StaticArrays.jl  because everything is in plain numbers. For example:  using   DynamicalSystems  @inline   eom_logistic ( r )   =   ( x )   -   r * x * ( 1 - x )    # this is a closure  @inline   deriv_logistic ( r )   =   ( x )   -   r * ( 1 - 2 x )   # this is a closure  r   =   3.7  logistic   =   DiscreteDS1D ( rand (),   eom_logistic ( r ),   deriv_logistic ( r ))   Once again, if you skip the derivative functions it will be calculated automatically using  ForwardDiff.jl .", 
            "title": "1-dimensional Discrete Systems"
        }, 
        {
            "location": "/system_definition/#continuous-systems", 
            "text": "TBA", 
            "title": "Continuous Systems"
        }, 
        {
            "location": "/system_definition/#predefined-systems", 
            "text": "TBA", 
            "title": "Predefined Systems"
        }, 
        {
            "location": "/system_definition/#numerical-data", 
            "text": "TBA", 
            "title": "Numerical Data"
        }, 
        {
            "location": "/system_definition/#convenience-functions", 
            "text": "TBA", 
            "title": "Convenience Functions"
        }, 
        {
            "location": "/lyapunovs/", 
            "text": "Lyapunov Exponents\n\n\nLyapunov exponents measure rates of separation of nearby trajectories in the flow of a dynamical system. The \nWikipedia\n and the \nScholarpedia\n entries have a lot of valuable information about the history and usage of these quantities.\n\n\nThe naming comes after Aleksandr M. Lyapunov [1], a Russian mathematician/physicist that had major impact on the analysis of the stability of systems.\n\n\n[1] : See e.g. A.M. Lyapunov, \nThe General Problem of the Stability of Motion\n, Taylor \n Francis (1992) and references therein.\n\n\n\n\nDynamical Systems\n\n\nFor systems where the equations of motion are known, there two functions related with the computation of lyapunov exponents: \nlyapunovs\n and \nlyapunov\n.\n\n\n\n\nLyapunov Spectrum\n\n\nThe function \nlyapunovs\n calculates the entire spectrum of the exponents of a system:\n\n\n#\n\n\nDynamicalSystems.lyapunovs\n \n \nFunction\n.\n\n\nlyapunovs\n(\nds\n::\nDynamicalSystem\n,\n \nN\n;\n \nkwargs\n...\n)\n \n-\n \n[\n\u03bb1\n,\n \n\u03bb2\n,\n \n...\n,\n \n\u03bbD\n]\n\n\n\n\n\n\nCalculate the spectrum of lyapunov exponents [1] of the system \nds\n by applying the QR-decomposition method [2] \nN\n times. Returns a vector with the \nfinal\n values of the lyapunov exponents, ordered from bigger to smaller.\n\n\nKeyword Arguments:\n\n\n\n\nTtr\n : Extra \"transient\" time to evolve the system before application of the algorithm. Should be \nInt\n for discrete systems. Defaults are system type dependent.\n\n\ndt = 1.0\n : (only for continuous) Time of individual evolutions between sucessive orthonormalization steps.\n\n\ndiff_eq_kwargs = Dict()\n : (only for continuous) Keyword arguments passed into the solvers of the \nDifferentialEquations\n package (see \nevolve\n or \ntimeseries\n for more info).\n\n\n\n\n[1] : A.M. Lyapunov, \nThe General Problem of the Stability of Motion\n, Taylor \n Francis (1992)\n\n\n[2] : K. Geist \net al\n, Progr. Theor. Phys. \n83\n, pp 875 (1990)\n\n\nsource\n\n\nAs you can see, the documentation string is detailed and self-contained. For example, the lyapunov spectrum of the \nfolded towel map\n is calculated as:\n\n\nusing\n \nDynamicalSystems\n\n\n\nds\n \n=\n \nSystems\n.\ntowel\n()\n\n\n\u03bb\u03bb\n \n=\n \nlyapunovs\n(\nds\n,\n \n10000\n)\n\n\n# result:\n\n\n[\n0.432253\n,\n \n0.371617\n,\n \n-\n3.29632\n]\n\n\n\n\n\n\nSimilarly, for a continuous system, e.g. the Lorenz system, you would do:\n\n\nusing\n \nDynamicalSystems\n\n\n\nlor\n \n=\n \nSystems\n.\nlorenz\n(\n\u03c1\n \n=\n \n32.0\n)\n \n#this is not the original parameter!\n\n\nissubtype\n(\ntypeof\n(\nds\n),\n \nContinuousDS\n)\n \n# true\n\n\n\n\u03bb\u03bb\n \n=\n \nlyapunovs\n(\nlor\n,\n \n10000\n,\n\n\ndt\n \n=\n \n0.1\n,\n \ndiff_eq_kwargs\n \n=\n \nDict\n(\n:\nabstol\n \n=\n \n1e-9\n,\n \n:\nreltol\n \n=\n \n1e-9\n))\n\n\n# result:\n\n\n[\n0.999176\n,\n \n0.000774754\n,\n \n-\n14.6666\n]\n\n\n\n\n\n\n\n\nMaximum Lyapunov Exponent\n\n\nThe function \nlyapunov\n calculates the maximum lyapunov exponent of a system, much more efficiently than \nlyapunovs[1]\n:\n\n\n#\n\n\nDynamicalSystems.lyapunov\n \n \nFunction\n.\n\n\nlyapunov\n(\nds\n::\nDynamicalSystem\n,\n \n\u03a4\n;\n \nkwargs\n...\n)\n \n-\n \n\u03bb\n\n\n\n\n\n\nCalculate the maximum lyapunov exponent using a method due to Benettin [1], which simply evolves two neighboring trajectories while constantly rescaling one of the two. \nT\n  denotes the total time of evolution (should be \nInt\n for discrete systems).\n\n\nKeyword Arguments:\n\n\n\n\nTtr\n : Extra \"transient\" time to evolve the system before application of the algorithm. Should be \nInt\n for discrete systems. Defaults are system type dependent.\n\n\nd0 = 1e-9\n : Initial \n rescaling distance between two neighboring trajectories.\n\n\nthreshold = 1043*d0\n : Threshold to rescale the test trajectory.\n\n\ndiff_eq_kwargs = Dict()\n : (only for continuous) Keyword arguments passed into the solvers of the \nDifferentialEquations\n package (see \nevolve\n or \ntimeseries\n for more info).\n\n\ndt = 0.1\n : (only for continuous) Time of evolution between each check of distance e0xceeding the \nthreshold\n.\n\n\n\n\nWarning\n: Default values have been choosen to give accurate \n fast results for maximum lyapunov exponent expected between 0.1 to 1.0. Be sure to adjust them properly for your system.\n\n\n[1] : Benettin \net al.\n, Phys. Rev. A \n14\n, pp 2338 (1976)\n\n\nsource\n\n\nFor example:\n\n\nusing\n \nDynamicalSystems\n\n\n\nhenon\n \n=\n \nSystems\n.\nhenon\n()\n\n\n\u03bb\n \n=\n \nlyapunov\n(\nhenon\n,\n \n10000\n,\n \nd0\n \n=\n \n1e-7\n,\n \nthreshold\n \n=\n \n1e-4\n,\n \nTtr\n \n=\n \n100\n)\n\n\n# result:\n\n\n0.42011626111385747\n\n\n\n\n\n\nThe same is done for continuous systems:\n\n\nusing\n \nDynamicalSystems\n,\n \nOrdinaryDiffEq\n\n\n\nross\n \n=\n \nSystems\n.\nroessler\n(\na\n \n=\n \n0.1\n,\n \nb\n \n=\n \n0.1\n,\n \nc\n \n=\n \n14.0\n)\n \n#not original parameters\n\n\n\u03bb\n \n=\n \nlyapunov\n(\nross\n,\n \n10000\n,\n \ndt\n \n=\n \n0.5\n,\n \ndiff_eq_kwargs\n \n=\n \nDict\n(\n:\nsolver\n \n=\n \nVern8\n()))\n\n\n# result:\n\n\n0.06957484163052223\n\n\n\n\n\n\n\n\nNumerical Data\n\n\nTBA", 
            "title": "Lyapunov Exponents"
        }, 
        {
            "location": "/lyapunovs/#lyapunov-exponents", 
            "text": "Lyapunov exponents measure rates of separation of nearby trajectories in the flow of a dynamical system. The  Wikipedia  and the  Scholarpedia  entries have a lot of valuable information about the history and usage of these quantities.  The naming comes after Aleksandr M. Lyapunov [1], a Russian mathematician/physicist that had major impact on the analysis of the stability of systems.  [1] : See e.g. A.M. Lyapunov,  The General Problem of the Stability of Motion , Taylor   Francis (1992) and references therein.", 
            "title": "Lyapunov Exponents"
        }, 
        {
            "location": "/lyapunovs/#dynamical-systems", 
            "text": "For systems where the equations of motion are known, there two functions related with the computation of lyapunov exponents:  lyapunovs  and  lyapunov .", 
            "title": "Dynamical Systems"
        }, 
        {
            "location": "/lyapunovs/#lyapunov-spectrum", 
            "text": "The function  lyapunovs  calculates the entire spectrum of the exponents of a system:  #  DynamicalSystems.lyapunovs     Function .  lyapunovs ( ds :: DynamicalSystem ,   N ;   kwargs ... )   -   [ \u03bb1 ,   \u03bb2 ,   ... ,   \u03bbD ]   Calculate the spectrum of lyapunov exponents [1] of the system  ds  by applying the QR-decomposition method [2]  N  times. Returns a vector with the  final  values of the lyapunov exponents, ordered from bigger to smaller.  Keyword Arguments:   Ttr  : Extra \"transient\" time to evolve the system before application of the algorithm. Should be  Int  for discrete systems. Defaults are system type dependent.  dt = 1.0  : (only for continuous) Time of individual evolutions between sucessive orthonormalization steps.  diff_eq_kwargs = Dict()  : (only for continuous) Keyword arguments passed into the solvers of the  DifferentialEquations  package (see  evolve  or  timeseries  for more info).   [1] : A.M. Lyapunov,  The General Problem of the Stability of Motion , Taylor   Francis (1992)  [2] : K. Geist  et al , Progr. Theor. Phys.  83 , pp 875 (1990)  source  As you can see, the documentation string is detailed and self-contained. For example, the lyapunov spectrum of the  folded towel map  is calculated as:  using   DynamicalSystems  ds   =   Systems . towel ()  \u03bb\u03bb   =   lyapunovs ( ds ,   10000 )  # result:  [ 0.432253 ,   0.371617 ,   - 3.29632 ]   Similarly, for a continuous system, e.g. the Lorenz system, you would do:  using   DynamicalSystems  lor   =   Systems . lorenz ( \u03c1   =   32.0 )   #this is not the original parameter!  issubtype ( typeof ( ds ),   ContinuousDS )   # true  \u03bb\u03bb   =   lyapunovs ( lor ,   10000 ,  dt   =   0.1 ,   diff_eq_kwargs   =   Dict ( : abstol   =   1e-9 ,   : reltol   =   1e-9 ))  # result:  [ 0.999176 ,   0.000774754 ,   - 14.6666 ]", 
            "title": "Lyapunov Spectrum"
        }, 
        {
            "location": "/lyapunovs/#maximum-lyapunov-exponent", 
            "text": "The function  lyapunov  calculates the maximum lyapunov exponent of a system, much more efficiently than  lyapunovs[1] :  #  DynamicalSystems.lyapunov     Function .  lyapunov ( ds :: DynamicalSystem ,   \u03a4 ;   kwargs ... )   -   \u03bb   Calculate the maximum lyapunov exponent using a method due to Benettin [1], which simply evolves two neighboring trajectories while constantly rescaling one of the two.  T   denotes the total time of evolution (should be  Int  for discrete systems).  Keyword Arguments:   Ttr  : Extra \"transient\" time to evolve the system before application of the algorithm. Should be  Int  for discrete systems. Defaults are system type dependent.  d0 = 1e-9  : Initial   rescaling distance between two neighboring trajectories.  threshold = 1043*d0  : Threshold to rescale the test trajectory.  diff_eq_kwargs = Dict()  : (only for continuous) Keyword arguments passed into the solvers of the  DifferentialEquations  package (see  evolve  or  timeseries  for more info).  dt = 0.1  : (only for continuous) Time of evolution between each check of distance e0xceeding the  threshold .   Warning : Default values have been choosen to give accurate   fast results for maximum lyapunov exponent expected between 0.1 to 1.0. Be sure to adjust them properly for your system.  [1] : Benettin  et al. , Phys. Rev. A  14 , pp 2338 (1976)  source  For example:  using   DynamicalSystems  henon   =   Systems . henon ()  \u03bb   =   lyapunov ( henon ,   10000 ,   d0   =   1e-7 ,   threshold   =   1e-4 ,   Ttr   =   100 )  # result:  0.42011626111385747   The same is done for continuous systems:  using   DynamicalSystems ,   OrdinaryDiffEq  ross   =   Systems . roessler ( a   =   0.1 ,   b   =   0.1 ,   c   =   14.0 )   #not original parameters  \u03bb   =   lyapunov ( ross ,   10000 ,   dt   =   0.5 ,   diff_eq_kwargs   =   Dict ( : solver   =   Vern8 ()))  # result:  0.06957484163052223", 
            "title": "Maximum Lyapunov Exponent"
        }, 
        {
            "location": "/lyapunovs/#numerical-data", 
            "text": "TBA", 
            "title": "Numerical Data"
        }
    ]
}